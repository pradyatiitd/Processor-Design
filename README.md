# Processor-Design

## Part - 1
### Aim
This assignment aims at designing ARM datapath modules and implementing these on the BASYS3 board. The following subset of ARM instructions has been chosen for implementation.

Arithmetic: <add|sub|rsb|adc|sbc|rsc> {cond} {s}<br/>
Logical: <and | orr | eor | bic> {cond} {s}<br/>
Test: <cmp | cmn | teq | tst> {cond}<br/>
Move: <mov | mvn> {cond} {s}<br/>
Branch: <b | bl> {cond}<br/>
Multiply: <mul | mla> {cond} {s}<br/>
Load/store: <ldr | str> {cond} {b | h | sb | sh }<br/>
cond: <EQ|NE|CS|CC|MI|PL|VS|VC|HI|LS|GE|LT|GT|LE|AL><br/>
<br/>
Instructions excluded are as follows:<br/>
Co-processor: cdp, mcr, mrc, ldc, stc<br/>
Branch and exchange: bx<br/>
Load/Store multiple: ldm, stm<br/>
Software interrupt: swi <br/>
Atomic swap: swp<br/>
PSR transfer: mrs, msr<br/>
Multiply long: mull, mlal<br/>

Instruction swi will be added later. Following are the building blocks :-

### ALU
Inputs : two 32-bit operands, operation to be performed, carry<br/>
Outputs : 32-bit result of arithmetic/logical operation, next flag values<br/>

It is a combinational circuit that performs the arithmetic/logical operations for the DP instructions. The “operation to be performed” input can come from the opcode field of DP instructions. Its ability to add/subtract is also used by other instructions by giving appropriate inputs. This includes address offset addition/subtraction for DT and b|bl instructions as well as addition required in mla instruction. The ALU need not inherently know whether the addition it is doing is for add or ldr or bl or mla. Apart from the 32-bit result, the next values for the 4 flags are also output. Whether the flag values actually need to change is decided elsewhere.

### Shifter
Inputs : 32-bit data to be shifted, shift type (LSL|LSR|ASR|ROR) and shift amount<br/>
Outputs : 32-bit data after shifting, shifter carry<br/>

It is a combinational circuit that performs the required shift operation by the specified number of bits. This serves the purpose for DP and DT instructions requiring shift. It also outputs shifter carry. Which carry (ALU or shifter) is to be used for updating the carry flag is decided elsewhere.

### Multiplier
Inputs : Two 32-bit operands<br/>
Outputs : One 32-bit result<br/>

It is a combinational circuit that performs multiplication operation for mul and mla instructions. The addition required for mla instruction is done by ALU. For this assignment, a detailed design for multiplier is not required. Simply use multiply symbol in VHDL and leave the rest to the synthesizer.

### Register File
Inputs : 32-bit data to be written, two 4-bit read addresses, one 4-bit write address, clock, reset, write enable<br/>
Outputs : two 32-bit data outputs, PC output<br/>

It has an array of sixteen 32-bit registers accessible through two read ports and one write port. It maintains a copy of register 15 out side the array for easy access as program counter. Clock and write enable have their usual meaning. Reset is used to initialize PC.

### Processor-Memory Path
Inputs : 32-bit data from processor, 32-bit data from memory, type of DT instruction, byte offset in memory address<br/>
Outputs : 32-bit data to processor, 32-bit data to memory, memory write enable signals<br/>

It is a combinational circuit that provides byte manipulation and sign/zero extension needed for ldrb, ldrh, ldrsb, ldrsh, strb and strh instructions. For byte addressable memory, byte level write enable signals are required. These are also generated by this module.


## Part - 2
### Overview
Datapath modules designed in week 6 are to be integrated to form the complete datapath. This will be a “multi-cycle” datapath, which means that it will allow instruction execution in multiple cycles. As opposed to a “single cycle” datapath, it provides for storage of temporary values computed at the end of intermediate cycles.

There are many ways in which the task of an instruction may be split into steps or micro- operations. What is proposed for this exercise is described below for various instruction groups. For DP and DT instructions Rn, Rd, Rs and Rm denote IR[19-16], IR[15-12], IR[11-8] and IR[3-0], respectively, where IR refers to the instruction. For multiply instructions Rn, Rd, Rs and Rm denote IR[15-12], IR[19-16], IR[11-8] and IR[3-0], respectively.

### DP Group
1. Fetch instruction from memory, address given by PC. Add 4 to PC.<br/>
2. Read operand(s) from register file.<br/>
      a. Read operand1 from Rn for all instructions except for move sub-group<br/>
      b. Read operand2 from Rm, if it is not immediate type<br/>
3. Read shift amount from register Rs in register file, if it is specified by a register<br/>
4. Shift/rotate operand2, if required.<br/>
5. Perform DP operation. Set flags if required.<br/>
6. Write result into register Rd of register file, if it is not compare or test sub-group instruction.<br/>

### DT Group
1. Fetch instruction from memory, address given by PC. Add 4 to PC.<br/>
2. Read base/offset from register file.<br/>
      a. Read base address from Rn in all cases<br/>
      b. Read offset from Rm, if it is specified by a register<br/>
3. Shift/rotate the offset, if required.<br/>
4. Add/subtract offset to base. In case of store instruction, read data from Rd of register file.<br/>
5. Perform memory read/write using address with/without offset (depending upon pre/post indexing). Write address (with offset) into register Rn of register file, if required.<br/>
6. Write the data read from memory into register Rd of register file in case of a load instruction.<br/>

### Branch Group
1. Fetch instruction from memory, address given by PC. Add 4 to PC. <br/>  
2. In case of BL instruction, write PC into lr register in register file. Add 4 to PC.<br/>
3. Add offset to PC.<br/>

### Multiply Group
1. Fetch instruction from memory, address given by PC. Add 4 to PC.<br/>
2. Read multiplicands from Rn and Rs of register file.<br/>
3. Read addend from Rm of register file, if it is MLA instruction. Perform multiplication.<br/>
4. Perform addition, if it is MLA instruction.<br/>
5. Write result into register Rd of register file.<br/>

### Notes
1. Actions shown in blue should be performed subject to the condition specified by IR[31-28] being satisfied.<br/>
2. The first step in all the instructions is common. It will help in simplifying controller design if the second step for all instructions is also made common (that is, always read from Rn and Rm, whether required or not). Then controller can look at the instruction type in step 2 and decide to follow different sequences for different cases from step 3 onwards.<br/>
3. The data path need not bother about sequencing of the steps or deciding whether a step is required or not. That is the job of the controller. In every cycle, the controller instructs the datapath to perform some step or micro-operations.<br/>
